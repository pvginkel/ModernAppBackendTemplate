"""Pytest fixtures for testing."""

import os
{% if use_database %}
import tempfile
{% endif %}

import pytest
from flask import Flask
from flask.testing import FlaskClient
{% if use_database or use_s3 %}
from unittest.mock import patch
{% endif %}

# Set testing environment before importing app
os.environ["FLASK_ENV"] = "testing"
{% if use_database %}
# Use SQLite for testing
_test_db = tempfile.NamedTemporaryFile(suffix=".db", delete=False)
os.environ["DATABASE_URL"] = f"sqlite:///{_test_db.name}"
{% endif %}

from app.config import Settings, get_settings
from app.container import AppContainer
from common.core.app import create_app
{% if use_database %}
from common.database.extensions import db
{% endif %}


@pytest.fixture(scope="session")
def test_settings() -> Settings:
    """Create test settings."""
    # Clear cached settings
    get_settings.cache_clear()
    settings = get_settings()
{% if use_database %}
    # Configure SQLite-compatible engine options
    settings.set_engine_options_override({})
{% endif %}
    return settings


@pytest.fixture
def app(test_settings: Settings) -> Flask:
    """Create application for testing."""
    app = create_app(
        AppContainer,
        settings=test_settings,
        skip_background_services=True,
    )
    app.config["TESTING"] = True
{% if use_database %}

    # Create tables
    with app.app_context():
        db.create_all()

    yield app

    # Cleanup tables
    with app.app_context():
        db.drop_all()
{% else %}
    return app
{% endif %}


@pytest.fixture
def client(app: Flask) -> FlaskClient:
    """Create test client."""
    return app.test_client()


@pytest.fixture
def app_context(app: Flask):
    """Create application context."""
    with app.app_context():
        yield
{% if use_s3 %}


@pytest.fixture(autouse=True)
def mock_s3_health():
    """Mock S3 health check for all tests."""
    with patch("common.storage.health.check_s3_health", return_value=(True, "mocked")):
        yield
{% endif %}
