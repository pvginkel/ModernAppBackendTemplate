"""Health check endpoints for Kubernetes probes."""

import logging
from typing import Any

from dependency_injector.wiring import Provide, inject
from flask import Blueprint, jsonify, request
from spectree import Response as SpectreeResponse

from app.config import Settings
{% if use_database %}
from app.database import check_db_connection, get_pending_migrations
{% endif %}
from app.schemas.health_schema import HealthResponse
from app.services.container import ServiceContainer
from app.utils.lifecycle_coordinator import LifecycleCoordinatorProtocol
from app.utils.spectree_config import api

logger = logging.getLogger(__name__)

health_bp = Blueprint("health", __name__, url_prefix="/health")


@health_bp.route("/readyz", methods=["GET"])
@api.validate(resp=SpectreeResponse(HTTP_200=HealthResponse, HTTP_503=HealthResponse))
@inject
def readyz(
    lifecycle_coordinator: LifecycleCoordinatorProtocol = Provide[ServiceContainer.lifecycle_coordinator]
) -> Any:
    """Readiness probe endpoint for Kubernetes.

    Returns 503 when the application is shutting down{% if use_database %}, database is not ready,
    or migrations are pending{% endif %}. This signals Kubernetes to remove the pod from service endpoints.
    """
    # Check if shutdown has been initiated
    if lifecycle_coordinator.is_shutting_down():
        return jsonify({"status": "shutting down", "ready": False}), 503

{% if use_database %}
    # Check database connectivity
    db_connected = check_db_connection()
    if not db_connected:
        return jsonify({
            "status": "database unavailable",
            "ready": False,
            "database": {"connected": False}
        }), 503

    # Check for pending migrations
    pending_migrations = get_pending_migrations()
    if pending_migrations:
        return jsonify({
            "status": "migrations pending",
            "ready": False,
            "database": {"connected": True},
            "migrations": {"pending": len(pending_migrations)}
        }), 503

    # All checks passed
    return jsonify({
        "status": "ready",
        "ready": True,
        "database": {"connected": True},
        "migrations": {"pending": 0}
    }), 200
{% else %}
    # All checks passed
    return jsonify({
        "status": "ready",
        "ready": True,
    }), 200
{% endif %}


@health_bp.route("/healthz", methods=["GET"])
@api.validate(resp=SpectreeResponse(HTTP_200=HealthResponse))
def healthz() -> Any:
    """Liveness probe endpoint for Kubernetes.

    Always returns 200 to indicate the application is alive.
    This keeps the pod running even during graceful shutdown.
    """
    return jsonify({"status": "alive", "ready": True}), 200


@health_bp.route("/drain", methods=["GET"])
@api.validate(resp=SpectreeResponse(HTTP_200=HealthResponse, HTTP_401=HealthResponse))
@inject
def drain(
    lifecycle_coordinator: LifecycleCoordinatorProtocol = Provide[ServiceContainer.lifecycle_coordinator],
    settings: Settings = Provide[ServiceContainer.config]
) -> Any:
    """Drain endpoint for manual graceful shutdown initiation.

    Requires bearer token authentication against DRAIN_AUTH_KEY config setting.
    Calls shutdown() on the lifecycle coordinator and returns health status.
    """
    # Check if DRAIN_AUTH_KEY is configured
    if not settings.drain_auth_key:
        logger.error("DRAIN_AUTH_KEY not configured, rejecting drain request")
        return jsonify({"status": "unauthorized", "ready": False}), 401

    # Extract Authorization header
    auth_header = request.headers.get("Authorization", "")

    # Validate token
    if auth_header != f"Bearer {settings.drain_auth_key}":
        logger.warning("Drain request with invalid token")
        return jsonify({"status": "unauthorized", "ready": False}), 401

    # Call drain on lifecycle coordinator
    try:
        logger.info("Authenticated drain request received, calling starting drain")
        lifecycle_coordinator.shutdown()
        logger.info("Shutdown complete")
        return jsonify({"status": "alive", "ready": True}), 200
    except Exception as e:
        logger.error(f"Error calling drain(): {e}")
        return jsonify({"status": "error", "ready": False}), 500
