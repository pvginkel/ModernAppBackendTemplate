"""Health check endpoints for Kubernetes probes."""

import logging
from typing import Any

from dependency_injector.wiring import Provide, inject
from flask import Blueprint, jsonify, request

from common.core.shutdown import ShutdownCoordinatorProtocol
{% if use_database %}
from common.database.health import check_db_connection, get_pending_migrations
{% endif %}
{% if use_s3 %}
from common.storage.health import check_s3_health
from common.storage.s3_service import S3Service
{% endif %}
{% if use_oidc %}
from common.auth.routes import register_oidc_routes
{% endif %}

logger = logging.getLogger(__name__)

health_bp = Blueprint("health", __name__, url_prefix="/health")
{% if use_oidc %}

# Register OIDC auth routes on health blueprint
register_oidc_routes(health_bp)
{% endif %}


@health_bp.route("/healthz", methods=["GET"])
def healthz() -> Any:
    """Liveness probe endpoint for Kubernetes.

    Always returns 200 to indicate the application is alive.
    This keeps the pod running even during graceful shutdown.
    """
    return jsonify({"status": "alive", "ready": True}), 200


@health_bp.route("/readyz", methods=["GET"])
@inject
def readyz(
    shutdown_coordinator: ShutdownCoordinatorProtocol = Provide["shutdown_coordinator"],
{% if use_s3 %}
    s3_service: S3Service = Provide["s3_service"],
{% endif %}
) -> Any:
    """Readiness probe endpoint for Kubernetes.

    Returns 503 when the application is shutting down or unhealthy.
    This signals Kubernetes to remove the pod from service endpoints.
    """
    checks: dict[str, Any] = {}
    all_healthy = True

    # Check if shutdown has been initiated
    if shutdown_coordinator.is_shutting_down():
        return jsonify({"status": "shutting down", "ready": False}), 503
{% if use_database %}

    # Check database connectivity
    db_connected = check_db_connection()
    checks["database"] = {"connected": db_connected}
    if not db_connected:
        all_healthy = False
    else:
        # Check for pending migrations
        pending_migrations = get_pending_migrations()
        if pending_migrations:
            checks["migrations"] = {"pending": len(pending_migrations)}
            return jsonify({
                "status": "migrations pending",
                "ready": False,
                **checks,
            }), 503
        checks["migrations"] = {"pending": 0}
{% endif %}
{% if use_s3 %}

    # Check S3 connectivity
    s3_healthy, s3_message = check_s3_health(s3_service)
    checks["s3"] = {"healthy": s3_healthy, "message": s3_message}
    if not s3_healthy:
        all_healthy = False
{% endif %}

    if not all_healthy:
        return jsonify({
            "status": "unhealthy",
            "ready": False,
            **checks,
        }), 503

    return jsonify({
        "status": "ready",
        "ready": True,
        **checks,
    }), 200

{% if use_database %}

@health_bp.route("/drain", methods=["GET"])
@inject
def drain(
    shutdown_coordinator: ShutdownCoordinatorProtocol = Provide["shutdown_coordinator"],
    settings: Any = Provide["config"],
) -> Any:
    """Drain endpoint for manual graceful shutdown initiation.

    Requires bearer token authentication against DRAIN_AUTH_KEY config setting.
    Calls shutdown() on the shutdown coordinator and returns health status.
    """
    # Check if DRAIN_AUTH_KEY is configured
    drain_auth_key = getattr(settings, "DRAIN_AUTH_KEY", None)
    if not drain_auth_key:
        logger.error("DRAIN_AUTH_KEY not configured, rejecting drain request")
        return jsonify({"status": "unauthorized", "ready": False}), 401

    # Extract Authorization header
    auth_header = request.headers.get("Authorization", "")

    # Validate token
    if auth_header != f"Bearer {drain_auth_key}":
        logger.warning("Drain request with invalid token")
        return jsonify({"status": "unauthorized", "ready": False}), 401

    # Call shutdown on shutdown coordinator
    try:
        logger.info("Authenticated drain request received, starting drain")
        shutdown_coordinator.shutdown()
        logger.info("Shutdown complete")
        return jsonify({"status": "drained", "ready": True}), 200
    except Exception as e:
        logger.error(f"Error during drain: {e}")
        return jsonify({"status": "error", "ready": False}), 500
{% endif %}
