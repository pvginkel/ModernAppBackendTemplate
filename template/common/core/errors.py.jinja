"""Centralized error handling utilities."""

import functools
import logging
import uuid
from collections.abc import Callable
from typing import Any

from flask import Flask, current_app, g, jsonify, request
from flask.wrappers import Response
from pydantic import ValidationError
{% if use_database %}
from sqlalchemy.exc import IntegrityError
{% endif %}
from werkzeug.exceptions import BadRequest

logger = logging.getLogger(__name__)


class BusinessLogicException(Exception):
    """Base exception for business logic errors."""

    def __init__(self, message: str, error_code: str | None = None):
        self.message = message
        self.error_code = error_code
        super().__init__(message)


class RecordNotFoundException(BusinessLogicException):
    """Raised when a requested record is not found."""

    pass


class ResourceConflictException(BusinessLogicException):
    """Raised when a resource conflict occurs."""

    pass


class InvalidOperationException(BusinessLogicException):
    """Raised when an operation cannot be performed."""

    pass


def get_request_id() -> str:
    """Get the current request ID from flask.g, or generate one if not set."""
    if hasattr(g, "request_id") and g.request_id:
        return g.request_id
    return str(uuid.uuid4())


def setup_request_id() -> None:
    """Set up request ID for the current request.

    Uses X-Request-ID header if provided, otherwise generates a new UUID.
    Call this in @app.before_request.
    """
    g.request_id = request.headers.get("X-Request-ID") or str(uuid.uuid4())


def _build_error_response(
    error: str,
    details: dict[str, Any],
    code: str | None = None,
    status_code: int = 400,
) -> tuple[Response, int]:
    """Build error response with request ID for correlation."""
    response_data: dict[str, Any] = {
        "error": error,
        "details": details,
        "request_id": get_request_id(),
    }

    if code:
        response_data["code"] = code

    return jsonify(response_data), status_code


def handle_api_errors(
    func: Callable[..., Any]
) -> Callable[..., Response | tuple[Response | str, int]]:
    """Decorator to handle common API errors consistently.

    Handles ValidationError, IntegrityError, and generic exceptions
    with appropriate HTTP status codes and error messages.
    """

    @functools.wraps(func)
    def wrapper(*args: Any, **kwargs: Any) -> Any:
        try:
            return func(*args, **kwargs)
        except Exception as e:
{% if use_database %}
            # Mark session for rollback when any exception is caught
            try:
                container = current_app.container
                db_session = container.db_session()
                db_session.info["needs_rollback"] = True
            except Exception:
                pass
{% endif %}
            # Log all exceptions with stack trace
            logger.error("Exception in %s: %s", func.__name__, str(e), exc_info=True)

            # Handle specific exception types
            try:
                raise
            except BadRequest:
                return _build_error_response(
                    "Invalid JSON",
                    {"message": "Request body must be valid JSON"},
                    status_code=400,
                )

            except ValidationError as e:
                error_details = []
                for error in e.errors():
                    field = ".".join(str(x) for x in error["loc"])
                    message = error["msg"]
                    error_details.append({"message": message, "field": field})

                return _build_error_response(
                    "Validation failed",
                    {"errors": error_details},
                    status_code=400,
                )

            except RecordNotFoundException as e:
                return _build_error_response(
                    e.message,
                    {"message": "The requested resource could not be found"},
                    code=e.error_code,
                    status_code=404,
                )

            except ResourceConflictException as e:
                return _build_error_response(
                    e.message,
                    {"message": "A resource conflict occurred"},
                    code=e.error_code,
                    status_code=409,
                )

            except InvalidOperationException as e:
                return _build_error_response(
                    e.message,
                    {"message": "The requested operation cannot be performed"},
                    code=e.error_code,
                    status_code=409,
                )

            except BusinessLogicException as e:
                return _build_error_response(
                    e.message,
                    {"message": "A business logic operation failed"},
                    code=e.error_code,
                    status_code=400,
                )
{% if use_database %}
            except IntegrityError as e:
                error_msg = str(e.orig) if hasattr(e, "orig") else str(e)

                if "UNIQUE constraint failed" in error_msg or "duplicate key" in error_msg.lower():
                    return _build_error_response(
                        "Resource already exists",
                        {"message": "A record with these values already exists"},
                        status_code=409,
                    )
                elif "FOREIGN KEY constraint failed" in error_msg or "foreign key" in error_msg.lower():
                    return _build_error_response(
                        "Invalid reference",
                        {"message": "Referenced resource does not exist"},
                        status_code=400,
                    )
                else:
                    return _build_error_response(
                        "Database constraint violation",
                        {"message": "The operation violates a database constraint"},
                        status_code=400,
                    )
{% endif %}
            except Exception as e:
                return _build_error_response(
                    "Internal server error",
                    {"message": str(e)},
                    status_code=500,
                )

    return wrapper


def register_error_handlers(app: Flask) -> None:
    """Register Flask error handlers for common HTTP errors."""

    @app.errorhandler(404)
    def not_found(error: Exception) -> tuple[Response, int]:
        return jsonify({"error": "Resource not found"}), 404

    @app.errorhandler(500)
    def internal_error(error: Exception) -> tuple[Response, int]:
        app.logger.error(f"Internal server error: {error}")
        return jsonify({"error": "Internal server error"}), 500
